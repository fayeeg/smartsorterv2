<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Smart Sorter - Stable</title>
<style>
  body { font-family: sans-serif; text-align: center; margin: 0; padding: 0; background: #f4f4f4; }
  h2 { background: #2196f3; color: white; padding: 10px; margin: 0; }
  button { margin: 10px; padding: 10px 20px; font-size: 1em; border: none; border-radius: 5px; background: #4caf50; color: white; cursor: pointer; }
  button:hover { background: #45a049; }
  button.stop { background: #f44336; }
  video { max-width: 100%; height: auto; border: 2px solid #2196f3; }
  #label-container div { font-size: 1.2em; margin: 5px; padding: 8px; background: white; border-radius: 5px; }
  .highlight { font-weight: bold; color: white; background: #2196f3 !important; }
  #status, #debug { margin: 10px; padding: 10px; background: #fff; border-radius: 5px; }
</style>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
</head>
<body>
<h2>Smart Trash Sorter (Stable Mode)</h2>
<div id="status">Loading model...</div>
<button id="startBtn">Start</button>
<button id="bleBtn">Connect BLE</button>
<button id="stopBtn" class="stop">Stop</button>
<div id="webcam-container"></div>
<div id="label-container"></div>
<div id="debug">Debug: Waiting...</div>
<script>
window.onload = async function() {
    // Force CPU backend to avoid WebGL memory issues
    await tf.setBackend('cpu');
    console.log('Using backend:', tf.getBackend());
    
    const MODEL_URL = "./web_model/model.json";
    const CLASS_LABELS = ["cardboard", "glass", "metal", "paper", "plastic", "trash"];
    
    let model, videoElement, labelContainer;
    let bleDevice, bleCharacteristic;
    let animationId = null;
    let statusDiv = document.getElementById("status");
    let debugDiv = document.getElementById("debug");
    
    let lastSentCommand = "";
    let lastSentTime = 0;
    let frameCount = 0;
    let isSendingBLE = false; // Prevent concurrent BLE sends
    
    document.getElementById("startBtn").onclick = init;
    document.getElementById("bleBtn").onclick = connectBLE;
    document.getElementById("stopBtn").onclick = stopAll;
    
    loadModel();
    
    async function loadModel() {
        try {
            statusDiv.innerHTML = "Loading model...";
            model = await tf.loadLayersModel(MODEL_URL);
            statusDiv.innerHTML = "Model loaded! Click Start.";
            statusDiv.style.background = "#d4edda";
            console.log("Model loaded");
        } catch (err) {
            statusDiv.innerHTML = "Error: " + err.message;
            statusDiv.style.background = "#f8d7da";
        }
    }
    
    async function init() {
        try {
            if (!model) {
                alert("Model not ready");
                return;
            }
            
            videoElement = document.createElement("video");
            videoElement.width = 224;
            videoElement.height = 224;
            videoElement.autoplay = true;
            videoElement.playsInline = true;
            
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { 
                    facingMode: "environment",
                    width: 224,
                    height: 224
                }
            });
            
            videoElement.srcObject = stream;
            await new Promise(resolve => videoElement.onloadedmetadata = resolve);
            
            document.getElementById("webcam-container").appendChild(videoElement);
            
            labelContainer = document.getElementById("label-container");
            labelContainer.innerHTML = "";
            for (let i = 0; i < 6; i++) {
                labelContainer.appendChild(document.createElement("div"));
            }
            
            statusDiv.innerHTML = "Running...";
            loop();
        } catch (err) {
            alert("Camera error: " + err.message);
        }
    }
    
    function loop() {
        if (videoElement && videoElement.readyState === 4) {
            // Only predict every 3rd frame to reduce load
            if (frameCount % 3 === 0) {
                predict();
            }
            frameCount++;
        }
        animationId = requestAnimationFrame(loop);
    }
    
    async function predict() {
        await tf.tidy(() => {
            try {
                // Everything in tidy() is automatically cleaned up
                const img = tf.browser.fromPixels(videoElement)
                    .resizeNearestNeighbor([224, 224])
                    .toFloat()
                    .div(255.0)
                    .expandDims(0);
                
                const pred = model.predict(img);
                
                // Must read data synchronously inside tidy
                pred.data().then(predictions => {
                    let maxProb = 0;
                    let maxIndex = 0;
                    
                    for (let i = 0; i < 6; i++) {
                        if (predictions[i] > maxProb) {
                            maxProb = predictions[i];
                            maxIndex = i;
                        }
                        
                        labelContainer.childNodes[i].innerHTML = 
                            `${CLASS_LABELS[i]}: ${(predictions[i] * 100).toFixed(1)}%`;
                        labelContainer.childNodes[i].className = 
                            (i === maxIndex) ? "highlight" : "";
                    }
                    
                    const bestClass = CLASS_LABELS[maxIndex];
                    
                    // Send to BLE with throttling
                    const now = Date.now();
                    if (bleCharacteristic && maxProb > 0.6 && !isSendingBLE) {
                        if (bestClass !== lastSentCommand || (now - lastSentTime) > 3000) {
                            sendBLE(bestClass);
                            lastSentCommand = bestClass;
                            lastSentTime = now;
                        }
                    }
                    
                    // Memory monitoring
                    if (frameCount % 30 === 0) {
                        const mem = tf.memory();
                        debugDiv.innerHTML = `Frames: ${frameCount} | Tensors: ${mem.numTensors} | Memory: ${(mem.numBytes/1024/1024).toFixed(1)}MB`;
                        
                        // Auto-restart if memory leaks
                        if (mem.numTensors > 100) {
                            console.error("Memory leak detected! Restarting...");
                            stopAll().then(() => setTimeout(init, 1000));
                        }
                    }
                });
            } catch (err) {
                console.error("Prediction error:", err);
            }
        });
    }
    
    async function sendBLE(command) {
        if (isSendingBLE) return; // Prevent concurrent sends
        
        isSendingBLE = true;
        try {
            const encoder = new TextEncoder();
            await bleCharacteristic.writeValue(encoder.encode(command));
            console.log(`Sent: ${command}`);
            statusDiv.innerHTML = `Sent: ${command}`;
        } catch (err) {
            console.error("BLE error:", err.message);
        } finally {
            isSendingBLE = false;
        }
    }
    
    async function connectBLE() {
        try {
            bleDevice = await navigator.bluetooth.requestDevice({
                filters: [{ services: ["6e400001-b5a3-f393-e0a9-e50e24dcca9e"] }]
            });
            
            const server = await bleDevice.gatt.connect();
            const service = await server.getPrimaryService("6e400001-b5a3-f393-e0a9-e50e24dcca9e");
            bleCharacteristic = await service.getCharacteristic("6e400003-b5a3-f393-e0a9-e50e24dcca9e");
            
            statusDiv.innerHTML = "BLE Connected!";
            alert("Connected!");
        } catch (err) {
            alert("BLE failed: " + err.message);
        }
    }
    
    async function stopAll() {
        if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
        }
        
        if (videoElement && videoElement.srcObject) {
            videoElement.srcObject.getTracks().forEach(t => t.stop());
            videoElement.srcObject = null;
            document.getElementById("webcam-container").innerHTML = "";
            videoElement = null;
        }
        
        if (bleDevice && bleDevice.gatt.connected) {
            await bleDevice.gatt.disconnect();
            bleDevice = null;
            bleCharacteristic = null;
        }
        
        if (labelContainer) labelContainer.innerHTML = "";
        
        // Force garbage collection
        if (window.gc) window.gc();
        
        statusDiv.innerHTML = "Stopped";
        debugDiv.innerHTML = "Debug: Stopped | Memory: " + JSON.stringify(tf.memory());
        
        frameCount = 0;
        lastSentCommand = "";
        isSendingBLE = false;
        
        console.log("Stopped. Final memory:", tf.memory());
    }
};
</script>
</body>
</html>
